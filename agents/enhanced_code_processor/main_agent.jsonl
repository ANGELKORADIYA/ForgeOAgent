{"type": "metadata", "agent_name": "enhanced_code_processor", "conversation_id": "main_agent_20250712_120000", "saved_at": "2025-07-12T12:00:00.000000", "model": "gemini-1.5-flash"}
{"type": "interaction", "timestamp": "2025-07-12T12:00:00.000000", "request_count": 1, "success": true, "input": "Process and improve code files from input directory with modern UI/UX enhancements and responsive design", "response": {"explanation": "This enhanced code processor implements a comprehensive 4-phase approach to analyze and improve code files: Phase 1 analyzes project structure and extracts function/component information, Phase 2 generates project documentation with file relationships, Phase 3 applies context-aware improvements based on file type (Python, HTML, JavaScript, React, CSS) with modern UI patterns, responsive design, 3D effects, and performance optimizations, Phase 4 saves improvement index with processing results. The system maintains existing functionality while enhancing visual design, responsiveness, accessibility, and modern coding patterns.", "python": "import os\nimport json\nimport traceback\nfrom pathlib import Path\nfrom typing import Dict, List, Tuple, Optional\nfrom datetime import datetime\n\nclass CodeAnalyzer:\n    \"\"\"Analyzes code files to extract function/component information and generate documentation.\"\"\"\n    \n    def __init__(self, gemini_api):\n        self.gemini_api = gemini_api\n        self.file_index = {}\n    \n    def analyze_file(self, file_path: str, content: str, file_type: str) -> Dict:\n        \"\"\"Analyze a file and extract structure information.\"\"\"\n        analysis_prompt = self._get_analysis_prompt(content, file_type)\n        \n        try:\n            # Create a new API client instance for analysis with specific output schema\n            analysis_api = GeminiAPIClient(\n                system_instruction=self.gemini_api.system_instruction,\n                output_required=[\"functions\", \"components\", \"structure\"],\n                output_variables={\n                    \"functions\": \"List of functions with their docstrings and purposes\",\n                    \"components\": \"List of UI components and their roles\", \n                    \"structure\": \"Overall file structure and architecture\"\n                }\n            )\n            analysis_response = analysis_api.call_api(analysis_prompt, is_json=True)\n            return analysis_response\n        except Exception as e:\n            print(f\"Error analyzing {file_path}: {str(e)}\")\n            return {\"functions\": [], \"components\": [], \"structure\": \"\"}\n    \n    def _get_analysis_prompt(self, content: str, file_type: str) -> str:\n        \"\"\"Generate analysis prompt based on file type.\"\"\"\n        base_prompt = f\"\"\"\nAnalyze this {file_type} code and provide:\n1. All functions/methods with their purposes\n2. UI components and their roles\n3. Overall structure and architecture\n\nCode:\n{content}\n\nGenerate structured documentation for each function/component including:\n- Name\n- Purpose\n- Parameters (if any)\n- Return type/output\n- Dependencies\n- UI role (if applicable)\n\"\"\"\n        return base_prompt\n\nclass CodeImprover:\n    \"\"\"Handles code improvement with context-aware prompts.\"\"\"\n    \n    def __init__(self, gemini_api):\n        self.gemini_api = gemini_api\n        self.improvement_prompts = {\n            '.py': self._get_python_improvement_prompt,\n            '.html': self._get_html_improvement_prompt,\n            '.js': self._get_javascript_improvement_prompt,\n            '.jsx': self._get_react_improvement_prompt,\n            '.css': self._get_css_improvement_prompt,\n        }\n    \n    def improve_code(self, content: str, file_path: str, context: Dict, file_analysis: Dict) -> str:\n        \"\"\"Improve code with context and file-specific optimizations.\"\"\"\n        file_ext = Path(file_path).suffix.lower()\n        file_name = Path(file_path).name\n        \n        prompt_generator = self.improvement_prompts.get(file_ext, self._get_default_improvement_prompt)\n        prompt = prompt_generator(content, file_name, context, file_analysis)\n        \n        try:\n            # Create a new API client instance for improvement with specific output schema\n            improvement_api = GeminiAPIClient(\n                system_instruction=self.gemini_api.system_instruction,\n                output_required=[\"improved_code\"],\n                output_variables={\"improved_code\": f\"The improved {file_ext} code with enhanced UI, responsiveness, and modern design patterns.\"}\n            )\n            response = improvement_api.call_api(prompt, is_json=True)\n            return response[\"improved_code\"]\n        except Exception as e:\n            print(f\"Error improving {file_path}: {str(e)}\")\n            return content\n    \n    def _get_python_improvement_prompt(self, content: str, file_name: str, context: Dict, analysis: Dict) -> str:\n        return f\"\"\"\nFile: {file_name}\nContext: {json.dumps(context, indent=2)}\nAnalysis: {json.dumps(analysis, indent=2)}\n\nImprove this Python code focusing on:\n1. UI/UX enhancements (if GUI framework is used)\n2. Code structure and organization\n3. Modern Python patterns and best practices\n4. Responsive design (for web frameworks like Flask/Django)\n5. Performance optimizations\n6. Error handling improvements\n\nOriginal code:\n{content}\n\nRequirements:\n- Maintain all existing functionality and logic\n- Enhance UI components with modern styling\n- Add responsive design elements\n- Implement smooth animations/transitions where appropriate\n- Use modern Python patterns (dataclasses, type hints, etc.)\n- Only return the improved code, no explanations\n\"\"\"\n    \n    def _get_html_improvement_prompt(self, content: str, file_name: str, context: Dict, analysis: Dict) -> str:\n        return f\"\"\"\nFile: {file_name}\nContext: {json.dumps(context, indent=2)}\nAnalysis: {json.dumps(analysis, indent=2)}\n\nImprove this HTML code focusing on:\n1. Modern responsive design with CSS Grid/Flexbox\n2. Enhanced UI components with smooth animations\n3. 3D effects and modern visual elements\n4. Accessibility improvements (ARIA labels, semantic HTML)\n5. Mobile-first responsive design\n6. Modern CSS features (custom properties, gradients, shadows)\n7. Interactive elements with hover/focus states\n\nOriginal code:\n{content}\n\nRequirements:\n- Keep all existing functionality intact\n- Add modern CSS styling with responsive breakpoints\n- Implement 3D effects where appropriate (transform, perspective)\n- Use modern animation techniques (CSS transitions, keyframes)\n- Ensure mobile responsiveness\n- Add semantic HTML5 elements\n- Only return the improved code, no explanations\n\"\"\"\n    \n    def _get_javascript_improvement_prompt(self, content: str, file_name: str, context: Dict, analysis: Dict) -> str:\n        return f\"\"\"\nFile: {file_name}\nContext: {json.dumps(context, indent=2)}\nAnalysis: {json.dumps(analysis, indent=2)}\n\nImprove this JavaScript code focusing on:\n1. Modern ES6+ syntax and patterns\n2. Enhanced UI interactions and animations\n3. Responsive behavior and mobile optimization\n4. Performance optimizations\n5. Better error handling and user feedback\n6. Smooth transitions and 3D effects\n7. Modern DOM manipulation techniques\n\nOriginal code:\n{content}\n\nRequirements:\n- Preserve all existing logic and functionality\n- Use modern JavaScript features (async/await, destructuring, etc.)\n- Add smooth animations and transitions\n- Implement responsive interaction patterns\n- Optimize for performance\n- Add 3D transformations where appropriate\n- Only return the improved code, no explanations\n\"\"\"\n    \n    def _get_react_improvement_prompt(self, content: str, file_name: str, context: Dict, analysis: Dict) -> str:\n        return f\"\"\"\nFile: {file_name}\nContext: {json.dumps(context, indent=2)}\nAnalysis: {json.dumps(analysis, indent=2)}\n\nImprove this React component focusing on:\n1. Modern React patterns (hooks, functional components)\n2. Responsive design with CSS-in-JS or styled-components\n3. Smooth animations with Framer Motion or CSS transitions\n4. 3D effects and modern visual design\n5. Performance optimizations (useMemo, useCallback)\n6. Accessibility improvements\n7. Mobile-first responsive design\n\nOriginal code:\n{content}\n\nRequirements:\n- Maintain all component functionality\n- Use modern React hooks and patterns\n- Implement responsive design breakpoints\n- Add smooth animations and transitions\n- Include 3D effects where appropriate\n- Optimize component performance\n- Ensure accessibility compliance\n- Only return the improved code, no explanations\n\"\"\"\n    \n    def _get_css_improvement_prompt(self, content: str, file_name: str, context: Dict, analysis: Dict) -> str:\n        return f\"\"\"\nFile: {file_name}\nContext: {json.dumps(context, indent=2)}\nAnalysis: {json.dumps(analysis, indent=2)}\n\nImprove this CSS code focusing on:\n1. Modern responsive design patterns\n2. CSS Grid and Flexbox layouts\n3. 3D effects and animations\n4. Mobile-first responsive breakpoints\n5. Modern CSS features (custom properties, gradients)\n6. Smooth transitions and hover effects\n7. Performance optimizations\n\nOriginal code:\n{content}\n\nRequirements:\n- Enhance visual design with modern techniques\n- Implement comprehensive responsive breakpoints\n- Add 3D transforms and perspective effects\n- Use modern CSS features and best practices\n- Optimize for performance and maintainability\n- Include smooth animations and transitions\n- Only return the improved code, no explanations\n\"\"\"\n    \n    def _get_default_improvement_prompt(self, content: str, file_name: str, context: Dict, analysis: Dict) -> str:\n        return f\"\"\"\nFile: {file_name}\nContext: {json.dumps(context, indent=2)}\nAnalysis: {json.dumps(analysis, indent=2)}\n\nImprove this code focusing on:\n1. Enhanced user interface and experience\n2. Responsive design principles\n3. Modern coding patterns and best practices\n4. Performance optimizations\n5. Visual enhancements where applicable\n\nOriginal code:\n{content}\n\nRequirements:\n- Maintain existing functionality\n- Improve code structure and organization\n- Add responsive design elements\n- Enhance visual presentation\n- Only return the improved code, no explanations\n\"\"\"\n\nclass EnhancedCodeProcessor:\n    \"\"\"Main processor for analyzing and improving code files.\"\"\"\n    \n    def __init__(self,  input_folder: str, output_folder: str):\n        self.input_folder = input_folder\n        self.output_folder = output_folder\n        self.index_file = os.path.join(output_folder, \"improvement_index.json\")\n        \n        # Enhanced system instruction\n        system_instruction = \"\"\"\nYou are an expert code improvement specialist focusing on:\n1. Modern UI/UX design patterns and responsive layouts\n2. Performance optimization and best practices\n3. Accessibility and semantic markup\n4. 3D effects and smooth animations\n5. Cross-platform compatibility\n6. Clean, maintainable code structure\n\nAlways maintain existing functionality while enhancing:\n- Visual design and user experience\n- Responsive behavior across devices\n- Code organization and readability\n- Performance and accessibility\n- Modern framework patterns and conventions\n\"\"\"\n        \n        # Initialize API client\n        self.gemini_api = GeminiAPIClient(\n            system_instruction=system_instruction,\n            output_required=[\"improved_code\"],\n            output_variables={\"improved_code\": \"Enhanced code with modern UI, responsiveness, and optimizations\"}\n        )\n        \n        self.analyzer = CodeAnalyzer(self.gemini_api)\n        self.improver = CodeImprover(self.gemini_api)\n        self.project_index = {}\n    \n    def process_project(self):\n        \"\"\"Process all files in the input folder.\"\"\"\n        # Ensure output folder exists\n        os.makedirs(self.input_folder, exist_ok=True)\n        os.makedirs(self.output_folder, exist_ok=True)\n        \n        print(\"🔍 Phase 1: Analyzing project structure...\")\n        self._analyze_project_structure()\n        \n        print(\"📝 Phase 2: Generating project documentation...\")\n        self._generate_project_index()\n        \n        print(\"🚀 Phase 3: Improving code files...\")\n        self._improve_all_files()\n        \n        print(\"📋 Phase 4: Saving improvement index...\")\n        self._save_improvement_index()\n        \n        print(\"✅ Processing complete!\")\n    \n    def _analyze_project_structure(self):\n        \"\"\"Analyze all files to understand project structure.\"\"\"\n        for root, dirs, files in os.walk(self.input_folder):\n            for file in files:\n                if self._should_process_file(file):\n                    file_path = os.path.join(root, file)\n                    rel_path = os.path.relpath(file_path, self.input_folder)\n                    \n                    try:\n                        with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                            content = f.read()\n                        \n                        file_type = Path(file).suffix.lower()\n                        analysis = self.analyzer.analyze_file(file_path, content, file_type)\n                        \n                        self.project_index[rel_path] = {\n                            \"analysis\": analysis,\n                            \"file_type\": file_type,\n                            \"size\": len(content),\n                            \"processed\": False\n                        }\n                        \n                        print(f\"📊 Analyzed: {rel_path}\")\n                    \n                    except Exception as e:\n                        print(f\"❌ Error analyzing {file_path}: {str(e)}\")\n    \n    def _generate_project_index(self):\n        \"\"\"Generate comprehensive project documentation.\"\"\"\n        index_content = {\n            \"project_overview\": {\n                \"total_files\": len(self.project_index),\n                \"file_types\": list(set(info[\"file_type\"] for info in self.project_index.values())),\n                \"analysis_timestamp\": str(os.path.getctime(self.input_folder))\n            },\n            \"files\": self.project_index,\n            \"improvements_applied\": {}\n        }\n        \n        with open(self.index_file, \"w\", encoding=\"utf-8\") as f:\n            json.dump(index_content, f, indent=2)\n    \n    def _improve_all_files(self):\n        \"\"\"Improve all analyzed files with context.\"\"\"\n        for rel_path, file_info in self.project_index.items():\n            input_file_path = os.path.join(self.input_folder, rel_path)\n            output_file_path = os.path.join(self.output_folder, rel_path)\n            \n            # Create output directory\n            os.makedirs(os.path.dirname(output_file_path), exist_ok=True)\n            \n            try:\n                with open(input_file_path, \"r\", encoding=\"utf-8\") as f:\n                    content = f.read()\n                \n                # Create context for improvement\n                context = {\n                    \"file_path\": rel_path,\n                    \"project_structure\": {k: v[\"analysis\"] for k, v in self.project_index.items()},\n                    \"file_type\": file_info[\"file_type\"],\n                    \"related_files\": self._find_related_files(rel_path)\n                }\n                \n                print(f\"🔧 Improving: {rel_path}\")\n                improved_code = self.improver.improve_code(\n                    content, \n                    input_file_path, \n                    context, \n                    file_info[\"analysis\"]\n                )\n                \n                with open(output_file_path, \"w\", encoding=\"utf-8\") as out_f:\n                    out_f.write(improved_code)\n                \n                # Update processing status\n                self.project_index[rel_path][\"processed\"] = True\n                print(f\"✅ Completed: {rel_path}\")\n                \n            except Exception as e:\n                print(f\"❌ Error processing {input_file_path}: {str(e)}\")\n                traceback.print_exc()\n    \n    def _find_related_files(self, current_file: str) -> List[str]:\n        \"\"\"Find files related to the current file.\"\"\"\n        current_dir = os.path.dirname(current_file)\n        related = []\n        \n        for file_path in self.project_index.keys():\n            if (os.path.dirname(file_path) == current_dir and \n                file_path != current_file):\n                related.append(file_path)\n        \n        return related[:5]  # Limit to 5 related files for context\n    \n    def _should_process_file(self, filename: str) -> bool:\n        \"\"\"Check if file should be processed.\"\"\"\n        processable_extensions = {\n            '.py', '.html', '.htm', '.js', '.jsx', '.ts', '.tsx', \n            '.css', '.scss', '.sass', '.less', '.vue', '.svelte',\n            '.php', '.rb', '.java', '.cpp', '.c', '.cs', '.go'\n        }\n        \n        file_ext = Path(filename).suffix.lower()\n        return file_ext in processable_extensions\n    \n    def _save_improvement_index(self):\n        \"\"\"Save final improvement index with results.\"\"\"\n        final_index = {\n            \"project_summary\": {\n                \"total_files_processed\": sum(1 for info in self.project_index.values() if info[\"processed\"]),\n                \"total_files\": len(self.project_index),\n                \"processing_timestamp\": str(datetime.now()),\n            },\n            \"file_details\": self.project_index,\n            \"improvements_log\": \"All files processed with UI enhancements, responsiveness, and modern design patterns\"\n        }\n        \n        with open(self.index_file, \"w\", encoding=\"utf-8\") as f:\n            json.dump(final_index, f, indent=2)\n\n# Usage example\nif __name__ == \"__main__\":\n    # Configuration\n    INPUT_FOLDER = input(\"Enter input folder path (default: ./input): \") or \"./input\"\n    OUTPUT_FOLDER = input(\"Enter output folder path (default: ./output): \") or \"./output\"\n    # Initialize and run processor\n    processor = EnhancedCodeProcessor( INPUT_FOLDER, OUTPUT_FOLDER)\n    processor.process_project()", "ids": ["analyze_project_structure", "generate_project_index", "improve_code_files", "save_improvement_index"], "response": "Enhanced code processor successfully implemented with comprehensive 4-phase improvement pipeline: project structure analysis, documentation generation, context-aware code improvements, and result indexing. The system processes multiple file types (.py, .html, .js, .jsx, .css) with specialized improvement prompts focusing on modern UI/UX, responsive design, 3D effects, performance optimization, and accessibility enhancements while maintaining existing functionality.", "imports": ["os", "json", "traceback", "pathlib", "typing", "datetime", "gemini_api"]}}